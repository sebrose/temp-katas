{"cyber-dojo.sh":"echo 'Unit Tests'\nrspec . --format documentation\n\necho 'Specification'\n# Test output can be formatted as progress or documentation\ncucumber -f progress ./*.feature -r *steps.rb\n","coordinate_spec.rb":"require_relative 'coordinate'\n\ndescribe Coordinate do\n  it \"calculates the distance from itself\" do\n    a = Coordinate.new(0, 0)\n    expect(a.distance_from(a)).to eq(0)\n  end\n\n  it \"calculates the distance from another coordinate along x axis\" do\n    a = Coordinate.new(0, 0)\n    b = Coordinate.new(600, 0)\n    expect(a.distance_from(b)).to eq(600)\n  end\n\n  it \"calculates the distance from another coordinate\" do\n    a = Coordinate.new(0, 0)\n    b = Coordinate.new(300, 400)\n    expect(a.distance_from(b)).to eq(500)\n  end\nend\n","coordinate.rb":"class Coordinate\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\n\n  def distance_from(other)\n    Math.sqrt( (@x - other.x)**2 + (@y -other.y)**2 )\n  end\n    \nend\n","env.rb":"","hear_shout.feature":"Feature: Hear Shout\n\n  Shouts have a range of approximately 1000m\n\n\n\n\n  Scenario Outline: Only hear in range shouts\n    Given Lucy is at 0, 0\n    And Sean is at <Seans location>\n    When Sean shouts\n    Then Lucy should hear <what lucy hears>\n  \n  Examples:  \n    | Seans location | what lucy hears |\n    | 0, 900         | Sean            |\n    | 800, 800       | nothing         |\n\n  Scenario: Multiple shouters\n    Given people are located at \n    | name  | x    | y   |\n    | Lucy  | 0    | 0   |\n    | Sean  | 0    | 500 |\n    | Oscar | 1100 | 0   |\n    When Sean shouts\n    And Oscar shouts\n    Then Lucy should not hear Oscar\n    But Lucy should hear Sean\n    \n  Scenario: Shouters should not hear thier own shouts\n    When Sean shouts\n    Then Sean should not hear Sean","shout_steps.rb":"require_relative 'shouty'\n\nARBITRARY_MESSAGE = \"Hello, world\"\n\nBefore do\n  @shouty = Shouty.new\n  @people = Array.new\nend\n\nGiven('{word} is at {int}, {int}') do |person, x, y|\n  set_person_location(person,x,y)\nend\n\nGiven(\"people are located at\") do |table|\n  table.map_column!('x') { |x| x.to_i }.map_column!('y') { |y| y.to_i }\n  table.hashes.each do | row |\n    set_person_location(row[:name],row[:x], row[:y])\n  end\nend\n\nWhen('{word} shouts') do |shouter|\n  set_person_location(shouter, 0, 0) if !@people.include? shouter \n  @shouty.shout(shouter, ARBITRARY_MESSAGE)\nend\n\nThen('{word} should hear Sean') do | listener |\n  expect(@shouty.shouts_heard_by(listener).size).to eq(1)\nend\n\nThen('{word} should hear nothing') do | listener |\n  expect(@shouty.shouts_heard_by(listener).size).to eq(0)\nend\n\nThen(\"{word} should not hear {word}\") do | listener, shouter |\n  expect(@shouty.shouts_heard_by(listener)).not_to include(shouter)\nend\n\ndef set_person_location(person,x,y)\n  @shouty.set_location(person, Coordinate.new(x, y))\n  @people.push person\nend","shouty.rb":"require_relative 'coordinate'\n\nclass Shouty\n    MESSAGE_RANGE = 1000\n\n    def initialize\n      @locations = {}\n      @shouts = {}\n    end\n\n    def set_location(person, location)\n      @locations[person] = location\n    end\n\n    def shout(person, shout)\n      @shouts[person] ||= [ ]\n      @shouts[person].push(shout)\n    end\n\n    def shouts_heard_by(listener)\n      shoutsHeard = {}\n\n      @shouts.each do |shouter, personsShouts|\n        distance = @locations[listener].distance_from(@locations[shouter])\n        if distance < MESSAGE_RANGE && shouter != listener\n          shoutsHeard[shouter] = personsShouts\n        end\n      end\n\n      shoutsHeard\n    end\nend\n","spec_helper.rb":"# This file was generated by the `rspec --init` command. Conventionally, all\n# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.\n# The generated `.rspec` file contains `--require spec_helper` which will cause\n# this file to always be loaded, without a need to explicitly require it in any\n# files.\n#\n# Given that it is always loaded, you are encouraged to keep this file as\n# light-weight as possible. Requiring heavyweight dependencies from this file\n# will add to the boot time of your test suite on EVERY test run, even for an\n# individual file that may not need all of that loaded. Instead, consider making\n# a separate helper file that requires the additional dependencies and performs\n# the additional setup, and require it from the spec files that actually need\n# it.\n#\n# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration\nRSpec.configure do |config|\n  # rspec-expectations config goes here. You can use an alternate\n  # assertion/expectation library such as wrong or the stdlib/minitest\n  # assertions if you prefer.\n  config.expect_with :rspec do |expectations|\n    # This option will default to `true` in RSpec 4. It makes the `description`\n    # and `failure_message` of custom matchers include text for helper methods\n    # defined using `chain`, e.g.:\n    #     be_bigger_than(2).and_smaller_than(4).description\n    #     # => \"be bigger than 2 and smaller than 4\"\n    # ...rather than:\n    #     # => \"be bigger than 2\"\n    expectations.include_chain_clauses_in_custom_matcher_descriptions = true\n  end\n\n  # rspec-mocks config goes here. You can use an alternate test double\n  # library (such as bogus or mocha) by changing the `mock_with` option here.\n  config.mock_with :rspec do |mocks|\n    # Prevents you from mocking or stubbing a method that does not exist on\n    # a real object. This is generally recommended, and will default to\n    # `true` in RSpec 4.\n    mocks.verify_partial_doubles = true\n  end\n\n  # This option will default to `:apply_to_host_groups` in RSpec 4 (and will\n  # have no way to turn it off -- the option exists only for backwards\n  # compatibility in RSpec 3). It causes shared context metadata to be\n  # inherited by the metadata hash of host groups and examples, rather than\n  # triggering implicit auto-inclusion in groups with matching metadata.\n  config.shared_context_metadata_behavior = :apply_to_host_groups\n\n# The settings below are suggested to provide a good initial experience\n# with RSpec, but feel free to customize to your heart's content.\n=begin\n  # This allows you to limit a spec run to individual examples or groups\n  # you care about by tagging them with `:focus` metadata. When nothing\n  # is tagged with `:focus`, all examples get run. RSpec also provides\n  # aliases for `it`, `describe`, and `context` that include `:focus`\n  # metadata: `fit`, `fdescribe` and `fcontext`, respectively.\n  config.filter_run_when_matching :focus\n\n  # Allows RSpec to persist some state between runs in order to support\n  # the `--only-failures` and `--next-failure` CLI options. We recommend\n  # you configure your source control system to ignore this file.\n  config.example_status_persistence_file_path = \"spec/examples.txt\"\n\n  # Limits the available syntax to the non-monkey patched syntax that is\n  # recommended. For more details, see:\n  #   - http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/\n  #   - http://www.teaisaweso.me/blog/2013/05/27/rspecs-new-message-expectation-syntax/\n  #   - http://rspec.info/blog/2014/05/notable-changes-in-rspec-3/#zero-monkey-patching-mode\n  config.disable_monkey_patching!\n\n  # This setting enables warnings. It's recommended, but in some cases may\n  # be too noisy due to issues in dependencies.\n  config.warnings = true\n\n  # Many RSpec users commonly either run the entire suite or an individual\n  # file, and it's useful to allow more verbose output when running an\n  # individual spec file.\n  if config.files_to_run.one?\n    # Use the documentation formatter for detailed output,\n    # unless a formatter has already been configured\n    # (e.g. via a command-line flag).\n    config.default_formatter = \"doc\"\n  end\n\n  # Print the 10 slowest examples and example groups at the\n  # end of the spec run, to help surface which specs are running\n  # particularly slow.\n  config.profile_examples = 10\n\n  # Run specs in random order to surface order dependencies. If you find an\n  # order dependency and want to debug it, you can fix the order by providing\n  # the seed, which is printed after each run.\n  #     --seed 1234\n  config.order = :random\n\n  # Seed global randomization in this process using the `--seed` CLI option.\n  # Setting this allows you to use `--seed` to deterministically reproduce\n  # test failures related to randomization by passing the same `--seed` value\n  # as the one that triggered the failure.\n  Kernel.srand config.seed\n=end\nend\n","output":"Unit Tests\n\nCoordinate\n  calculates the distance from itself\n  calculates the distance from another coordinate along x axis\n  calculates the distance from another coordinate\n\nShouty\n  #initialize\n    can be created\n  .shouts_heard_by\n    does not hear shouts from self\n\nFinished in 0.01384 seconds (files took 0.12985 seconds to load)\n5 examples, 0 failures\n\nSpecification\n...............\n\n4 scenarios (4 passed)\n15 steps (15 passed)\n0m0.036s\n","shouty_spec.rb":"require_relative 'shouty'\n\ndescribe Shouty do\n  \n  let (:shouty) { Shouty.new }\n  \n  describe '#initialize' do\n    \n    it 'can be created' do\n      shouty = Shouty.new \n    end\n\n  end\n  \n  describe '.shouts_heard_by' do\n    let(:listener_location) do \n      location = double\n      allow(location).to receive(:distance_from).and_return(100)\n      location\n    end\n  \n    it 'does not hear shouts from self' do\n      shouty.set_location('A Person', listener_location)\n      shouty.shout('A Person', 'A Message')\n      expect(shouty.shouts_heard_by('A Person')).to be_empty\n    end \n  end\n  \nend"}